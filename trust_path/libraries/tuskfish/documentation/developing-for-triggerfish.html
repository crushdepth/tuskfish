<h1>Developing for Tuskfish CMS</h1>
<h2>Essential</h2>
<p>All dynamic pages should include the following files, which make the database credentials and language constants available:
<ul>
    <li>TFISH_ROOT_PATH . header.php</li>
    <li>and TFISH_ROOT_PATH . footer.php</li>
</ul>
<h2>Template variables</h2>
<p>Tuskfish does not use a third-party template engine, it relies on the native capabilities of PHP to avoid overhead and cruft.
<p><strong>Convention</strong>: Variables for user-side display must be appended to the $template array, which is initialised by header.php and 
    available on all pages. Default values are set for $template['title'], $template['description'], $template['author'] and $template['copyright'] 
    are set automatically from the site configuration data. Overwrite these values to customise them for a page.</p>
<h2>Libraries</h2>
<p><strong>Convention</strong>: Libraries must be placed in a subfolder of /libraries, bearing the name of the library. For ease of code maintenance, 
    library file names shall have any version information removed (eg. jquery-1.10.min.js should be placedin/renamed to /libraries/jquery/jquery.js).</p>
<h2>Security</h2>
<p>Classes and other components should not trust one another; any parameter passed into a public method from an external source must be filtered, 
    no exceptions. This is to ensure that Tuskfish remains resistant to attack and escalation - if one component is compromised, it should not 
    enable abuse of other components. This does mean a certain amount of overhead and duplication - but it also provides a degree of safety should 
    an error be introduced somewhere.</p>
<h2>Database</h2>
<p>Database table names may only contain alphanumeric characters.</p>
<h2>Sanitising, validating and escaping policy</h2>
<p>Project policy is as follows (compliance is mandatory for contributors).</p>
<p>To summarise project philosophy:</p>
<p>The project does not try to "sanitise" input parameters. Rather, data is VALIDATED as far 
    as possible according to expectations and business rules - eg. if you are expecting an email 
    address, then the input should conform to the email specification. And if it 
    doesn't then you should REJECT it because trying to "fix" it is unlikely to help. In fact, in 
    this case, trying to fix a broken email address is likely to make things <i>worse</i>.</li>
<li>Data does, of course, need to be escaped. Project policy is to apply the appropriate form of 
    escaping <i>at the point of use</i>. For example, to use data in a query you must take steps to 
    guard against SQL injection; and to send data to the browser you must take steps to guard 
    against cross-site scripting. These two use cases require DIFFERENT forms of escaping; trying 
    to guard against every form of attack at the point of <i>input</i> when you <i>don't know the 
        context in which data will (later) be used</i>. In fact, it <i>creates</i> problems. For 
    example, if you encode entities in your input to prevent XSS attacks you will also break any 
    search queries that involve entities (O'Reilly => O&apos;Reilly) and you will also break any 
    legitimate mark up. It just doesn't make sense. Escaping the data at the point of use, when 
    you actually know the context of its use, is the way to go.</p>
<p>Escaping is primarily handled as follows:</p>

<ol>
    <li>Escaping of database queries is handled through EXCLUSIVE use of prepared statements with 
        bound parameters/values via PDO. So long as you use the TfishDatabase methods for your 
        database operations you don't need to worry about escaping quotes or SQL injection, because 
        everything is automatically escaped for you. In the interests of security contributors MUST 
        NOT write and execute your own queries. If you need additional database functionality then 
        let's talk about adding more methods to the TfishDatabase class that will handle your 
        needs in a secure and well-tested fashion.</li>
    <li>Escaping of output is handled via TfishDatafilter::escape(), which is simply a
        wrapper for htmlspecialchars with encoding of quotes and UTF-8 arguments. Pass all output 
        that is destined to be <i>enclosed within HTML tags</i> through this method before sending 
        it for display. Note that you should not pass  the surrounding HTML tags through this 
        method as they will get encoded.</li>
    <li>100% usage of UTF-8 character encoding on everything from files to input to database. There 
        are NO EXCEPTIONS. If input comes in non UTF-8 form the datafilter classes will reject it.</li>
    <li>Data originating from external sources (eg. users) MUST be validated by the 
        controller script that collected it. Use the static methods provided for this purpose in 
        the TfishDatafilter class. These are autoloaded and may be accessed anywhere using the
        format $clean_text = TfishDatafilter::trimString($dirty_text) and similar. Note that 
        these methods DO NOT ENCODE QUOTES and they DO NOT ENCODE ENTITIES and therefore are not 
        database safe in themselves. However, they do strip tags and null bytes etc and they also 
        check for and enforce UTF-8 compliance.</li>
    <li>Public methods in TuskFish classes MUST validate all input parameters. Yes, 
        this adds a layer of redundancy, but it provides i) a safety net in the event that a mistake is 
        made in a controller script and ii) prevents breakages in one component of Tuskfish being 
        used to exploit other components. Basically, the principle is that Tuskfish classes should 
        not trust one another. Once again, neither quotes nor entities are encoded at this 
        level.</li>
</ol>